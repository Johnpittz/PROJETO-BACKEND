{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n  constructor(opts) {\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n  parse(buffer, callback) {\n    this.mergeBuffer(buffer);\n    const bufferFullLength = this.bufferOffset + this.bufferLength;\n    let offset = this.bufferOffset;\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset];\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer;\n      this.bufferLength = 0;\n      this.bufferOffset = 0;\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset;\n      this.bufferOffset = offset;\n    }\n  }\n  mergeBuffer(buffer) {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength;\n      const newFullLength = newLength + this.bufferOffset;\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer;\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer;\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2;\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2;\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength);\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n        this.buffer = newBuffer;\n        this.bufferOffset = 0;\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n      this.bufferLength = newLength;\n    } else {\n      this.buffer = buffer;\n      this.bufferOffset = 0;\n      this.bufferLength = buffer.byteLength;\n    }\n  }\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50 /* BindComplete */:\n        return messages_1.bindComplete;\n      case 49 /* ParseComplete */:\n        return messages_1.parseComplete;\n      case 51 /* CloseComplete */:\n        return messages_1.closeComplete;\n      case 110 /* NoData */:\n        return messages_1.noData;\n      case 115 /* PortalSuspended */:\n        return messages_1.portalSuspended;\n      case 99 /* CopyDone */:\n        return messages_1.copyDone;\n      case 87 /* ReplicationStart */:\n        return messages_1.replicationStart;\n      case 73 /* EmptyQuery */:\n        return messages_1.emptyQuery;\n      case 68 /* DataRow */:\n        return this.parseDataRowMessage(offset, length, bytes);\n      case 67 /* CommandComplete */:\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n      case 90 /* ReadyForQuery */:\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n      case 65 /* NotificationResponse */:\n        return this.parseNotificationMessage(offset, length, bytes);\n      case 82 /* AuthenticationResponse */:\n        return this.parseAuthenticationResponse(offset, length, bytes);\n      case 83 /* ParameterStatus */:\n        return this.parseParameterStatusMessage(offset, length, bytes);\n      case 75 /* BackendKeyData */:\n        return this.parseBackendKeyData(offset, length, bytes);\n      case 69 /* ErrorMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'error');\n      case 78 /* NoticeMessage */:\n        return this.parseErrorMessage(offset, length, bytes, 'notice');\n      case 84 /* RowDescriptionMessage */:\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n      case 116 /* ParameterDescriptionMessage */:\n        return this.parseParameterDescriptionMessage(offset, length, bytes);\n      case 71 /* CopyIn */:\n        return this.parseCopyInMessage(offset, length, bytes);\n      case 72 /* CopyOut */:\n        return this.parseCopyOutMessage(offset, length, bytes);\n      case 100 /* CopyData */:\n        return this.parseCopyData(offset, length, bytes);\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n  }\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n  }\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n    return message;\n  }\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n    return message;\n  }\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n  parseParameterDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const parameterCount = this.reader.int16();\n    const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32();\n    }\n    return message;\n  }\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32();\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n    return new messages_1.DataRowMessage(length, fields);\n  }\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32();\n    // TODO(bmc): maybe better types here\n    const message = {\n      name: 'authenticationOk',\n      length\n    };\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword';\n        }\n        break;\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password';\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n        break;\n      case 10:\n        // AuthenticationSASL\n        message.name = 'authenticationSASL';\n        message.mechanisms = [];\n        let mechanism;\n        do {\n          mechanism = this.reader.cstring();\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n        break;\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue';\n        message.data = this.reader.string(length - 8);\n        break;\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal';\n        message.data = this.reader.string(length - 8);\n        break;\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n    return message;\n  }\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n    const messageValue = fields.M;\n    const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n}\nexports.Parser = Parser;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Parser","messages_1","require","buffer_reader_1","assert_1","CODE_LENGTH","LEN_LENGTH","HEADER_LENGTH","emptyBuffer","Buffer","allocUnsafe","constructor","opts","buffer","bufferLength","bufferOffset","reader","BufferReader","mode","Error","parse","callback","mergeBuffer","bufferFullLength","offset","code","length","readUInt32BE","fullMessageLength","message","handlePacket","newLength","byteLength","newFullLength","newBuffer","newBufferLength","copy","bytes","bindComplete","parseComplete","closeComplete","noData","portalSuspended","copyDone","replicationStart","emptyQuery","parseDataRowMessage","parseCommandCompleteMessage","parseReadyForQueryMessage","parseNotificationMessage","parseAuthenticationResponse","parseParameterStatusMessage","parseBackendKeyData","parseErrorMessage","parseRowDescriptionMessage","parseParameterDescriptionMessage","parseCopyInMessage","parseCopyOutMessage","parseCopyData","default","fail","toString","setBuffer","status","string","ReadyForQueryMessage","text","cstring","CommandCompleteMessage","chunk","slice","CopyDataMessage","parseCopyMessage","messageName","isBinary","byte","columnCount","int16","CopyResponse","i","columnTypes","processId","int32","channel","payload","NotificationResponseMessage","fieldCount","RowDescriptionMessage","fields","parseField","name","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","Field","parameterCount","ParameterDescriptionMessage","dataTypeIDs","Array","len","DataRowMessage","ParameterStatusMessage","processID","secretKey","BackendKeyDataMessage","salt","AuthenticationMD5Password","mechanisms","mechanism","push","data","fieldType","messageValue","M","NoticeMessage","DatabaseError","severity","S","C","detail","D","hint","H","position","P","internalPosition","p","internalQuery","q","where","W","schema","s","table","t","column","c","dataType","d","constraint","n","file","F","line","L","routine","R"],"sources":["C:/Users/joao2/Desktop/NOVO-PROJETO/node_modules/pg-protocol/dist/parser.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst messages_1 = require(\"./messages\");\nconst buffer_reader_1 = require(\"./buffer-reader\");\nconst assert_1 = __importDefault(require(\"assert\"));\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1;\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\nclass Parser {\n    constructor(opts) {\n        this.buffer = emptyBuffer;\n        this.bufferLength = 0;\n        this.bufferOffset = 0;\n        this.reader = new buffer_reader_1.BufferReader();\n        if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n            throw new Error('Binary mode not supported yet');\n        }\n        this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n    }\n    parse(buffer, callback) {\n        this.mergeBuffer(buffer);\n        const bufferFullLength = this.bufferOffset + this.bufferLength;\n        let offset = this.bufferOffset;\n        while (offset + HEADER_LENGTH <= bufferFullLength) {\n            // code is 1 byte long - it identifies the message type\n            const code = this.buffer[offset];\n            // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n            const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n            const fullMessageLength = CODE_LENGTH + length;\n            if (fullMessageLength + offset <= bufferFullLength) {\n                const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n                callback(message);\n                offset += fullMessageLength;\n            }\n            else {\n                break;\n            }\n        }\n        if (offset === bufferFullLength) {\n            // No more use for the buffer\n            this.buffer = emptyBuffer;\n            this.bufferLength = 0;\n            this.bufferOffset = 0;\n        }\n        else {\n            // Adjust the cursors of remainingBuffer\n            this.bufferLength = bufferFullLength - offset;\n            this.bufferOffset = offset;\n        }\n    }\n    mergeBuffer(buffer) {\n        if (this.bufferLength > 0) {\n            const newLength = this.bufferLength + buffer.byteLength;\n            const newFullLength = newLength + this.bufferOffset;\n            if (newFullLength > this.buffer.byteLength) {\n                // We can't concat the new buffer with the remaining one\n                let newBuffer;\n                if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n                    // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n                    newBuffer = this.buffer;\n                }\n                else {\n                    // Allocate a new larger buffer\n                    let newBufferLength = this.buffer.byteLength * 2;\n                    while (newLength >= newBufferLength) {\n                        newBufferLength *= 2;\n                    }\n                    newBuffer = Buffer.allocUnsafe(newBufferLength);\n                }\n                // Move the remaining buffer to the new one\n                this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n                this.buffer = newBuffer;\n                this.bufferOffset = 0;\n            }\n            // Concat the new buffer with the remaining one\n            buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n            this.bufferLength = newLength;\n        }\n        else {\n            this.buffer = buffer;\n            this.bufferOffset = 0;\n            this.bufferLength = buffer.byteLength;\n        }\n    }\n    handlePacket(offset, code, length, bytes) {\n        switch (code) {\n            case 50 /* BindComplete */:\n                return messages_1.bindComplete;\n            case 49 /* ParseComplete */:\n                return messages_1.parseComplete;\n            case 51 /* CloseComplete */:\n                return messages_1.closeComplete;\n            case 110 /* NoData */:\n                return messages_1.noData;\n            case 115 /* PortalSuspended */:\n                return messages_1.portalSuspended;\n            case 99 /* CopyDone */:\n                return messages_1.copyDone;\n            case 87 /* ReplicationStart */:\n                return messages_1.replicationStart;\n            case 73 /* EmptyQuery */:\n                return messages_1.emptyQuery;\n            case 68 /* DataRow */:\n                return this.parseDataRowMessage(offset, length, bytes);\n            case 67 /* CommandComplete */:\n                return this.parseCommandCompleteMessage(offset, length, bytes);\n            case 90 /* ReadyForQuery */:\n                return this.parseReadyForQueryMessage(offset, length, bytes);\n            case 65 /* NotificationResponse */:\n                return this.parseNotificationMessage(offset, length, bytes);\n            case 82 /* AuthenticationResponse */:\n                return this.parseAuthenticationResponse(offset, length, bytes);\n            case 83 /* ParameterStatus */:\n                return this.parseParameterStatusMessage(offset, length, bytes);\n            case 75 /* BackendKeyData */:\n                return this.parseBackendKeyData(offset, length, bytes);\n            case 69 /* ErrorMessage */:\n                return this.parseErrorMessage(offset, length, bytes, 'error');\n            case 78 /* NoticeMessage */:\n                return this.parseErrorMessage(offset, length, bytes, 'notice');\n            case 84 /* RowDescriptionMessage */:\n                return this.parseRowDescriptionMessage(offset, length, bytes);\n            case 116 /* ParameterDescriptionMessage */:\n                return this.parseParameterDescriptionMessage(offset, length, bytes);\n            case 71 /* CopyIn */:\n                return this.parseCopyInMessage(offset, length, bytes);\n            case 72 /* CopyOut */:\n                return this.parseCopyOutMessage(offset, length, bytes);\n            case 100 /* CopyData */:\n                return this.parseCopyData(offset, length, bytes);\n            default:\n                assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n        }\n    }\n    parseReadyForQueryMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const status = this.reader.string(1);\n        return new messages_1.ReadyForQueryMessage(length, status);\n    }\n    parseCommandCompleteMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const text = this.reader.cstring();\n        return new messages_1.CommandCompleteMessage(length, text);\n    }\n    parseCopyData(offset, length, bytes) {\n        const chunk = bytes.slice(offset, offset + (length - 4));\n        return new messages_1.CopyDataMessage(length, chunk);\n    }\n    parseCopyInMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n    }\n    parseCopyOutMessage(offset, length, bytes) {\n        return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n    }\n    parseCopyMessage(offset, length, bytes, messageName) {\n        this.reader.setBuffer(offset, bytes);\n        const isBinary = this.reader.byte() !== 0;\n        const columnCount = this.reader.int16();\n        const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n        for (let i = 0; i < columnCount; i++) {\n            message.columnTypes[i] = this.reader.int16();\n        }\n        return message;\n    }\n    parseNotificationMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processId = this.reader.int32();\n        const channel = this.reader.cstring();\n        const payload = this.reader.cstring();\n        return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n    }\n    parseRowDescriptionMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            message.fields[i] = this.parseField();\n        }\n        return message;\n    }\n    parseField() {\n        const name = this.reader.cstring();\n        const tableID = this.reader.int32();\n        const columnID = this.reader.int16();\n        const dataTypeID = this.reader.int32();\n        const dataTypeSize = this.reader.int16();\n        const dataTypeModifier = this.reader.int32();\n        const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n        return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n    parseParameterDescriptionMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const parameterCount = this.reader.int16();\n        const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n        for (let i = 0; i < parameterCount; i++) {\n            message.dataTypeIDs[i] = this.reader.int32();\n        }\n        return message;\n    }\n    parseDataRowMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const fieldCount = this.reader.int16();\n        const fields = new Array(fieldCount);\n        for (let i = 0; i < fieldCount; i++) {\n            const len = this.reader.int32();\n            // a -1 for length means the value of the field is null\n            fields[i] = len === -1 ? null : this.reader.string(len);\n        }\n        return new messages_1.DataRowMessage(length, fields);\n    }\n    parseParameterStatusMessage(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const name = this.reader.cstring();\n        const value = this.reader.cstring();\n        return new messages_1.ParameterStatusMessage(length, name, value);\n    }\n    parseBackendKeyData(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const processID = this.reader.int32();\n        const secretKey = this.reader.int32();\n        return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n    }\n    parseAuthenticationResponse(offset, length, bytes) {\n        this.reader.setBuffer(offset, bytes);\n        const code = this.reader.int32();\n        // TODO(bmc): maybe better types here\n        const message = {\n            name: 'authenticationOk',\n            length,\n        };\n        switch (code) {\n            case 0: // AuthenticationOk\n                break;\n            case 3: // AuthenticationCleartextPassword\n                if (message.length === 8) {\n                    message.name = 'authenticationCleartextPassword';\n                }\n                break;\n            case 5: // AuthenticationMD5Password\n                if (message.length === 12) {\n                    message.name = 'authenticationMD5Password';\n                    const salt = this.reader.bytes(4);\n                    return new messages_1.AuthenticationMD5Password(length, salt);\n                }\n                break;\n            case 10: // AuthenticationSASL\n                message.name = 'authenticationSASL';\n                message.mechanisms = [];\n                let mechanism;\n                do {\n                    mechanism = this.reader.cstring();\n                    if (mechanism) {\n                        message.mechanisms.push(mechanism);\n                    }\n                } while (mechanism);\n                break;\n            case 11: // AuthenticationSASLContinue\n                message.name = 'authenticationSASLContinue';\n                message.data = this.reader.string(length - 8);\n                break;\n            case 12: // AuthenticationSASLFinal\n                message.name = 'authenticationSASLFinal';\n                message.data = this.reader.string(length - 8);\n                break;\n            default:\n                throw new Error('Unknown authenticationOk message type ' + code);\n        }\n        return message;\n    }\n    parseErrorMessage(offset, length, bytes, name) {\n        this.reader.setBuffer(offset, bytes);\n        const fields = {};\n        let fieldType = this.reader.string(1);\n        while (fieldType !== '\\0') {\n            fields[fieldType] = this.reader.cstring();\n            fieldType = this.reader.string(1);\n        }\n        const messageValue = fields.M;\n        const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n        message.severity = fields.S;\n        message.code = fields.C;\n        message.detail = fields.D;\n        message.hint = fields.H;\n        message.position = fields.P;\n        message.internalPosition = fields.p;\n        message.internalQuery = fields.q;\n        message.where = fields.W;\n        message.schema = fields.s;\n        message.table = fields.t;\n        message.column = fields.c;\n        message.dataType = fields.d;\n        message.constraint = fields.n;\n        message.file = fields.F;\n        message.line = fields.L;\n        message.routine = fields.R;\n        return message;\n    }\n}\nexports.Parser = Parser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}