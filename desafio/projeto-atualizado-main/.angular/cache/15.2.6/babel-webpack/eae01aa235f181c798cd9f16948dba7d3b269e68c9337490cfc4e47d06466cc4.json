{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/joao2/Desktop/NOVO-PROJETO/desafio/projeto-atualizado-main/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EventEmitter } from 'events';\n/**\n * Wrapper around the Cloudflare built-in socket that can be used by the `Connection`.\n */\nexport class CloudflareSocket extends EventEmitter {\n  constructor(ssl) {\n    super();\n    this.ssl = ssl;\n    this.writable = false;\n    this.destroyed = false;\n    this._upgrading = false;\n    this._upgraded = false;\n    this._cfSocket = null;\n    this._cfWriter = null;\n    this._cfReader = null;\n  }\n  setNoDelay() {\n    return this;\n  }\n  setKeepAlive() {\n    return this;\n  }\n  ref() {\n    return this;\n  }\n  unref() {\n    return this;\n  }\n  connect(port, host, connectListener) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        log('connecting');\n        if (connectListener) _this.once('connect', connectListener);\n        const options = _this.ssl ? {\n          secureTransport: 'starttls'\n        } : {};\n        const {\n          connect\n        } = yield import('cloudflare:sockets');\n        _this._cfSocket = connect(`${host}:${port}`, options);\n        _this._cfWriter = _this._cfSocket.writable.getWriter();\n        _this._addClosedHandler();\n        _this._cfReader = _this._cfSocket.readable.getReader();\n        if (_this.ssl) {\n          _this._listenOnce().catch(e => _this.emit('error', e));\n        } else {\n          _this._listen().catch(e => _this.emit('error', e));\n        }\n        yield _this._cfWriter.ready;\n        log('socket ready');\n        _this.writable = true;\n        _this.emit('connect');\n        return _this;\n      } catch (e) {\n        _this.emit('error', e);\n      }\n    })();\n  }\n  _listen() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      while (true) {\n        log('awaiting receive from CF socket');\n        const {\n          done,\n          value\n        } = yield _this2._cfReader.read();\n        log('CF socket received:', done, value);\n        if (done) {\n          log('done');\n          break;\n        }\n        _this2.emit('data', Buffer.from(value));\n      }\n    })();\n  }\n  _listenOnce() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      log('awaiting first receive from CF socket');\n      const {\n        done,\n        value\n      } = yield _this3._cfReader.read();\n      log('First CF socket received:', done, value);\n      _this3.emit('data', Buffer.from(value));\n    })();\n  }\n  write(data, encoding = 'utf8', callback = () => {}) {\n    if (data.length === 0) return callback();\n    if (typeof data === 'string') data = Buffer.from(data, encoding);\n    log('sending data direct:', data);\n    this._cfWriter.write(data).then(() => {\n      log('data sent');\n      callback();\n    }, err => {\n      log('send error', err);\n      callback(err);\n    });\n    return true;\n  }\n  end(data = Buffer.alloc(0), encoding = 'utf8', callback = () => {}) {\n    log('ending CF socket');\n    this.write(data, encoding, err => {\n      this._cfSocket.close();\n      if (callback) callback(err);\n    });\n    return this;\n  }\n  destroy(reason) {\n    log('destroying CF socket', reason);\n    this.destroyed = true;\n    return this.end();\n  }\n  startTls(options) {\n    if (this._upgraded) {\n      // Don't try to upgrade again.\n      this.emit('error', 'Cannot call `startTls()` more than once on a socket');\n      return;\n    }\n    this._cfWriter.releaseLock();\n    this._cfReader.releaseLock();\n    this._upgrading = true;\n    this._cfSocket = this._cfSocket.startTls(options);\n    this._cfWriter = this._cfSocket.writable.getWriter();\n    this._cfReader = this._cfSocket.readable.getReader();\n    this._addClosedHandler();\n    this._listen().catch(e => this.emit('error', e));\n  }\n  _addClosedHandler() {\n    this._cfSocket.closed.then(() => {\n      if (!this._upgrading) {\n        log('CF socket closed');\n        this._cfSocket = null;\n        this.emit('close');\n      } else {\n        this._upgrading = false;\n        this._upgraded = true;\n      }\n    }).catch(e => this.emit('error', e));\n  }\n}\nconst debug = false;\nfunction dump(data) {\n  if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n    const hex = Buffer.from(data).toString('hex');\n    const str = new TextDecoder().decode(data);\n    return `\\n>>> STR: \"${str.replace(/\\n/g, '\\\\n')}\"\\n>>> HEX: ${hex}\\n`;\n  } else {\n    return data;\n  }\n}\nfunction log(...args) {\n  debug && console.log(...args.map(dump));\n}","map":{"version":3,"names":["EventEmitter","CloudflareSocket","constructor","ssl","writable","destroyed","_upgrading","_upgraded","_cfSocket","_cfWriter","_cfReader","setNoDelay","setKeepAlive","ref","unref","connect","port","host","connectListener","log","once","options","secureTransport","getWriter","_addClosedHandler","readable","getReader","_listenOnce","catch","e","emit","_listen","ready","done","value","read","Buffer","from","write","data","encoding","callback","length","then","err","end","alloc","close","destroy","reason","startTls","releaseLock","closed","debug","dump","Uint8Array","ArrayBuffer","hex","toString","str","TextDecoder","decode","replace","args","console","map"],"sources":["C:/Users/joao2/Desktop/NOVO-PROJETO/node_modules/pg-cloudflare/dist/index.js"],"sourcesContent":["import { EventEmitter } from 'events';\n/**\n * Wrapper around the Cloudflare built-in socket that can be used by the `Connection`.\n */\nexport class CloudflareSocket extends EventEmitter {\n    constructor(ssl) {\n        super();\n        this.ssl = ssl;\n        this.writable = false;\n        this.destroyed = false;\n        this._upgrading = false;\n        this._upgraded = false;\n        this._cfSocket = null;\n        this._cfWriter = null;\n        this._cfReader = null;\n    }\n    setNoDelay() {\n        return this;\n    }\n    setKeepAlive() {\n        return this;\n    }\n    ref() {\n        return this;\n    }\n    unref() {\n        return this;\n    }\n    async connect(port, host, connectListener) {\n        try {\n            log('connecting');\n            if (connectListener)\n                this.once('connect', connectListener);\n            const options = this.ssl ? { secureTransport: 'starttls' } : {};\n            const { connect } = await import('cloudflare:sockets');\n            this._cfSocket = connect(`${host}:${port}`, options);\n            this._cfWriter = this._cfSocket.writable.getWriter();\n            this._addClosedHandler();\n            this._cfReader = this._cfSocket.readable.getReader();\n            if (this.ssl) {\n                this._listenOnce().catch((e) => this.emit('error', e));\n            }\n            else {\n                this._listen().catch((e) => this.emit('error', e));\n            }\n            await this._cfWriter.ready;\n            log('socket ready');\n            this.writable = true;\n            this.emit('connect');\n            return this;\n        }\n        catch (e) {\n            this.emit('error', e);\n        }\n    }\n    async _listen() {\n        while (true) {\n            log('awaiting receive from CF socket');\n            const { done, value } = await this._cfReader.read();\n            log('CF socket received:', done, value);\n            if (done) {\n                log('done');\n                break;\n            }\n            this.emit('data', Buffer.from(value));\n        }\n    }\n    async _listenOnce() {\n        log('awaiting first receive from CF socket');\n        const { done, value } = await this._cfReader.read();\n        log('First CF socket received:', done, value);\n        this.emit('data', Buffer.from(value));\n    }\n    write(data, encoding = 'utf8', callback = () => { }) {\n        if (data.length === 0)\n            return callback();\n        if (typeof data === 'string')\n            data = Buffer.from(data, encoding);\n        log('sending data direct:', data);\n        this._cfWriter.write(data).then(() => {\n            log('data sent');\n            callback();\n        }, (err) => {\n            log('send error', err);\n            callback(err);\n        });\n        return true;\n    }\n    end(data = Buffer.alloc(0), encoding = 'utf8', callback = () => { }) {\n        log('ending CF socket');\n        this.write(data, encoding, (err) => {\n            this._cfSocket.close();\n            if (callback)\n                callback(err);\n        });\n        return this;\n    }\n    destroy(reason) {\n        log('destroying CF socket', reason);\n        this.destroyed = true;\n        return this.end();\n    }\n    startTls(options) {\n        if (this._upgraded) {\n            // Don't try to upgrade again.\n            this.emit('error', 'Cannot call `startTls()` more than once on a socket');\n            return;\n        }\n        this._cfWriter.releaseLock();\n        this._cfReader.releaseLock();\n        this._upgrading = true;\n        this._cfSocket = this._cfSocket.startTls(options);\n        this._cfWriter = this._cfSocket.writable.getWriter();\n        this._cfReader = this._cfSocket.readable.getReader();\n        this._addClosedHandler();\n        this._listen().catch((e) => this.emit('error', e));\n    }\n    _addClosedHandler() {\n        this._cfSocket.closed.then(() => {\n            if (!this._upgrading) {\n                log('CF socket closed');\n                this._cfSocket = null;\n                this.emit('close');\n            }\n            else {\n                this._upgrading = false;\n                this._upgraded = true;\n            }\n        }).catch((e) => this.emit('error', e));\n    }\n}\nconst debug = false;\nfunction dump(data) {\n    if (data instanceof Uint8Array || data instanceof ArrayBuffer) {\n        const hex = Buffer.from(data).toString('hex');\n        const str = new TextDecoder().decode(data);\n        return `\\n>>> STR: \"${str.replace(/\\n/g, '\\\\n')}\"\\n>>> HEX: ${hex}\\n`;\n    }\n    else {\n        return data;\n    }\n}\nfunction log(...args) {\n    debug && console.log(...args.map(dump));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}